/**
 * @popperjs/core v2.10.2 - MIT License
 */

'use strict'; !(function (e, t) { typeof exports === 'object' && typeof module !== 'undefined' ? t(exports) : typeof define === 'function' && define.amd ? define(['exports'], t) : t((e = typeof globalThis !== 'undefined' ? globalThis : e || self).Popper = {}) }(this, function (e) { function t (e, t) { return { width: (e = e.getBoundingClientRect()).width / 1, height: e.height / 1, top: e.top / 1, right: e.right / 1, bottom: e.bottom / 1, left: e.left / 1, x: e.left / 1, y: e.top / 1 } } function n (e) { return e == null ? window : e.toString() !== '[object Window]' ? (e = e.ownerDocument) && e.defaultView || window : e } function o (e) { return { scrollLeft: (e = n(e)).pageXOffset, scrollTop: e.pageYOffset } } function r (e) { return e instanceof n(e).Element || e instanceof Element } function i (e) { return e instanceof n(e).HTMLElement || e instanceof HTMLElement } function a (e) { return typeof ShadowRoot !== 'undefined' && (e instanceof n(e).ShadowRoot || e instanceof ShadowRoot) } function s (e) { return e ? (e.nodeName || '').toLowerCase() : null } function f (e) { return ((r(e) ? e.ownerDocument : e.document) || window.document).documentElement } function p (e) { return t(f(e)).left + o(e).scrollLeft } function c (e) { return n(e).getComputedStyle(e) } function l (e) { return e = c(e), /auto|scroll|overlay|hidden/.test(e.overflow + e.overflowY + e.overflowX) } function u (e, r, a) { void 0 === a && (a = !1); const c = i(r); i(r) && r.getBoundingClientRect(); const u = f(r); e = t(e); let d = { scrollLeft: 0, scrollTop: 0 }; let m = { x: 0, y: 0 }; return (c || !c && !a) && ((s(r) !== 'body' || l(u)) && (d = r !== n(r) && i(r) ? { scrollLeft: r.scrollLeft, scrollTop: r.scrollTop } : o(r)), i(r) ? ((m = t(r)).x += r.clientLeft, m.y += r.clientTop) : u && (m.x = p(u))), { x: e.left + d.scrollLeft - m.x, y: e.top + d.scrollTop - m.y, width: e.width, height: e.height } } function d (e) { const n = t(e); let o = e.offsetWidth; let r = e.offsetHeight; return Math.abs(n.width - o) <= 1 && (o = n.width), Math.abs(n.height - r) <= 1 && (r = n.height), { x: e.offsetLeft, y: e.offsetTop, width: o, height: r } } function m (e) { return s(e) === 'html' ? e : e.assignedSlot || e.parentNode || (a(e) ? e.host : null) || f(e) } function h (e) { return ['html', 'body', '#document'].indexOf(s(e)) >= 0 ? e.ownerDocument.body : i(e) && l(e) ? e : h(m(e)) } function v (e, t) { let o; void 0 === t && (t = []); let r = h(e); return e = r === ((o = e.ownerDocument) == null ? void 0 : o.body), o = n(r), r = e ? [o].concat(o.visualViewport || [], l(r) ? r : []) : r, t = t.concat(r), e ? t : t.concat(v(m(r))) } function g (e) { return i(e) && c(e).position !== 'fixed' ? e.offsetParent : null } function b (e) { for (var t = n(e), o = g(e); o && ['table', 'td', 'th'].indexOf(s(o)) >= 0 && c(o).position === 'static';)o = g(o); if (o && (s(o) === 'html' || s(o) === 'body' && c(o).position === 'static')) return t; if (!o)e: { if (o = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1, navigator.userAgent.indexOf('Trident') === -1 || !i(e) || c(e).position !== 'fixed') for (e = m(e); i(e) && ['html', 'body'].indexOf(s(e)) < 0;) { const r = c(e); if (r.transform !== 'none' || r.perspective !== 'none' || r.contain === 'paint' || ['transform', 'perspective'].indexOf(r.willChange) !== -1 || o && r.willChange === 'filter' || o && r.filter && r.filter !== 'none') { o = e; break e }e = e.parentNode }o = null } return o || t } function y (e) { function t (e) { o.add(e.name), [].concat(e.requires || [], e.requiresIfExists || []).forEach(function (e) { o.has(e) || (e = n.get(e)) && t(e) }), r.push(e) } var n = new Map(); var o = new Set(); var r = []; return e.forEach(function (e) { n.set(e.name, e) }), e.forEach(function (e) { o.has(e.name) || t(e) }), r } function w (e) { let t; return function () { return t || (t = new Promise(function (n) { Promise.resolve().then(function () { t = void 0, n(e()) }) })), t } } function x (e) { return e.split('-')[0] } function O (e, t) { const n = t.getRootNode && t.getRootNode(); if (e.contains(t)) return !0; if (n && a(n)) do { if (t && e.isSameNode(t)) return !0; t = t.parentNode || t.host } while (t); return !1 } function j (e) { return Object.assign({}, e, { left: e.x, top: e.y, right: e.x + e.width, bottom: e.y + e.height }) } function E (e, r) { if (r === 'viewport') { r = n(e); var a = f(e); r = r.visualViewport; var s = a.clientWidth; a = a.clientHeight; var l = 0; var u = 0; r && (s = r.width, a = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (l = r.offsetLeft, u = r.offsetTop)), e = j(e = { width: s, height: a, x: l + p(e), y: u }) } else i(r) ? ((e = t(r)).top += r.clientTop, e.left += r.clientLeft, e.bottom = e.top + r.clientHeight, e.right = e.left + r.clientWidth, e.width = r.clientWidth, e.height = r.clientHeight, e.x = e.left, e.y = e.top) : (u = f(e), e = f(u), s = o(u), r = (a = u.ownerDocument) == null ? void 0 : a.body, a = U(e.scrollWidth, e.clientWidth, r ? r.scrollWidth : 0, r ? r.clientWidth : 0), l = U(e.scrollHeight, e.clientHeight, r ? r.scrollHeight : 0, r ? r.clientHeight : 0), u = -s.scrollLeft + p(u), s = -s.scrollTop, c(r || e).direction === 'rtl' && (u += U(e.clientWidth, r ? r.clientWidth : 0) - a), e = j({ width: a, height: l, x: u, y: s })); return e } function D (e, t, n) { return t = t === 'clippingParents' ? (function (e) { const t = v(m(e)); const n = ['absolute', 'fixed'].indexOf(c(e).position) >= 0 && i(e) ? b(e) : e; return r(n) ? t.filter(function (e) { return r(e) && O(e, n) && s(e) !== 'body' }) : [] }(e)) : [].concat(t), (n = (n = [].concat(t, [n])).reduce(function (t, n) { return n = E(e, n), t.top = U(n.top, t.top), t.right = z(n.right, t.right), t.bottom = z(n.bottom, t.bottom), t.left = U(n.left, t.left), t }, E(e, n[0]))).width = n.right - n.left, n.height = n.bottom - n.top, n.x = n.left, n.y = n.top, n } function L (e) { return e.split('-')[1] } function P (e) { return ['top', 'bottom'].indexOf(e) >= 0 ? 'x' : 'y' } function M (e) { const t = e.reference; const n = e.element; let o = (e = e.placement) ? x(e) : null; e = e ? L(e) : null; let r = t.x + t.width / 2 - n.width / 2; let i = t.y + t.height / 2 - n.height / 2; switch (o) { case 'top':r = { x: r, y: t.y - n.height }; break; case 'bottom':r = { x: r, y: t.y + t.height }; break; case 'right':r = { x: t.x + t.width, y: i }; break; case 'left':r = { x: t.x - n.width, y: i }; break; default:r = { x: t.x, y: t.y } } if ((o = o ? P(o) : null) != null) switch (i = o === 'y' ? 'height' : 'width', e) { case 'start':r[o] -= t[i] / 2 - n[i] / 2; break; case 'end':r[o] += t[i] / 2 - n[i] / 2 } return r } function k (e) { return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, e) } function A (e, t) { return t.reduce(function (t, n) { return t[n] = e, t }, {}) } function B (e, n) { void 0 === n && (n = {}); let o = n; n = void 0 === (n = o.placement) ? e.placement : n; let i = o.boundary; let a = void 0 === i ? 'clippingParents' : i; let s = void 0 === (i = o.rootBoundary) ? 'viewport' : i; i = void 0 === (i = o.elementContext) ? 'popper' : i; let p = o.altBoundary; let c = void 0 !== p && p; o = k(typeof (o = void 0 === (o = o.padding) ? 0 : o) !== 'number' ? o : A(o, N)), p = e.rects.popper, a = D(r(c = e.elements[c ? i === 'popper' ? 'reference' : 'popper' : i]) ? c : c.contextElement || f(e.elements.popper), a, s), c = M({ reference: s = t(e.elements.reference), element: p, strategy: 'absolute', placement: n }), p = j(Object.assign({}, p, c)), s = i === 'popper' ? p : s; const l = { top: a.top - s.top + o.top, bottom: s.bottom - a.bottom + o.bottom, left: a.left - s.left + o.left, right: s.right - a.right + o.right }; if (e = e.modifiersData.offset, i === 'popper' && e) { const u = e[n]; Object.keys(l).forEach(function (e) { const t = ['right', 'bottom'].indexOf(e) >= 0 ? 1 : -1; const n = ['top', 'bottom'].indexOf(e) >= 0 ? 'y' : 'x'; l[e] += u[n] * t }) } return l } function W () { for (var e = arguments.length, t = Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return !t.some(function (e) { return !(e && typeof e.getBoundingClientRect === 'function') }) } function T (e) { void 0 === e && (e = {}); const t = e.defaultModifiers; const n = void 0 === t ? [] : t; const o = void 0 === (e = e.defaultOptions) ? X : e; return function (e, t, i) { function a () { f.forEach(function (e) { return e() }), f = [] } void 0 === i && (i = o); let s = { placement: 'bottom', orderedModifiers: [], options: Object.assign({}, X, o), modifiersData: {}, elements: { reference: e, popper: t }, attributes: {}, styles: {} }; var f = []; let p = !1; var c = { state: s, setOptions: function (i) { return i = typeof i === 'function' ? i(s.options) : i, a(), s.options = Object.assign({}, o, s.options, i), s.scrollParents = { reference: r(e) ? v(e) : e.contextElement ? v(e.contextElement) : [], popper: v(t) }, i = (function (e) { const t = y(e); return _.reduce(function (e, n) { return e.concat(t.filter(function (e) { return e.phase === n })) }, []) }(function (e) { const t = e.reduce(function (e, t) { const n = e[t.name]; return e[t.name] = n ? Object.assign({}, n, t, { options: Object.assign({}, n.options, t.options), data: Object.assign({}, n.data, t.data) }) : t, e }, {}); return Object.keys(t).map(function (e) { return t[e] }) }([].concat(n, s.options.modifiers)))), s.orderedModifiers = i.filter(function (e) { return e.enabled }), s.orderedModifiers.forEach(function (e) { let t = e.name; let n = e.options; n = void 0 === n ? {} : n, typeof (e = e.effect) === 'function' && (t = e({ state: s, name: t, instance: c, options: n }), f.push(t || function () {})) }), c.update() }, forceUpdate: function () { if (!p) { let e = s.elements; let t = e.reference; if (W(t, e = e.popper)) for (s.rects = { reference: u(t, b(e), s.options.strategy === 'fixed'), popper: d(e) }, s.reset = !1, s.placement = s.options.placement, s.orderedModifiers.forEach(function (e) { return s.modifiersData[e.name] = Object.assign({}, e.data) }), t = 0; t < s.orderedModifiers.length; t++) if (!0 === s.reset)s.reset = !1, t = -1; else { let n = s.orderedModifiers[t]; e = n.fn; let o = n.options; o = void 0 === o ? {} : o, n = n.name, typeof e === 'function' && (s = e({ state: s, options: o, name: n, instance: c }) || s) } } }, update: w(function () { return new Promise(function (e) { c.forceUpdate(), e(s) }) }), destroy: function () { a(), p = !0 } }; return W(e, t) ? (c.setOptions(i).then(function (e) { !p && i.onFirstUpdate && i.onFirstUpdate(e) }), c) : c } } function R (e) { let t; let o = e.popper; const r = e.popperRect; const i = e.placement; const a = e.variation; let s = e.offsets; const p = e.position; const l = e.gpuAcceleration; const u = e.adaptive; if (!0 === (e = e.roundOffsets)) { e = s.y; var d = window.devicePixelRatio || 1; e = { x: F(F(s.x * d) / d) || 0, y: F(F(e * d) / d) || 0 } } else e = typeof e === 'function' ? e(s) : s; e = void 0 === (e = (d = e).x) ? 0 : e, d = void 0 === (d = d.y) ? 0 : d; const m = s.hasOwnProperty('x'); s = s.hasOwnProperty('y'); let h; let v = 'left'; let g = 'top'; const y = window; if (u) { let w = b(o); let x = 'clientHeight'; let O = 'clientWidth'; w === n(o) && (c(w = f(o)).position !== 'static' && p === 'absolute' && (x = 'scrollHeight', O = 'scrollWidth')), i !== 'top' && (i !== 'left' && i !== 'right' || a !== 'end') || (g = 'bottom', d -= w[x] - r.height, d *= l ? 1 : -1), i !== 'left' && (i !== 'top' && i !== 'bottom' || a !== 'end') || (v = 'right', e -= w[O] - r.width, e *= l ? 1 : -1) } return o = Object.assign({ position: p }, u && K), l ? Object.assign({}, o, ((h = {})[g] = s ? '0' : '', h[v] = m ? '0' : '', h.transform = (y.devicePixelRatio || 1) <= 1 ? 'translate(' + e + 'px, ' + d + 'px)' : 'translate3d(' + e + 'px, ' + d + 'px, 0)', h)) : Object.assign({}, o, ((t = {})[g] = s ? d + 'px' : '', t[v] = m ? e + 'px' : '', t.transform = '', t)) } function H (e) { return e.replace(/left|right|bottom|top/g, function (e) { return ee[e] }) } function S (e) { return e.replace(/start|end/g, function (e) { return te[e] }) } function C (e, t, n) { return void 0 === n && (n = { x: 0, y: 0 }), { top: e.top - t.height - n.y, right: e.right - t.width + n.x, bottom: e.bottom - t.height + n.y, left: e.left - t.width - n.x } } function q (e) { return ['top', 'right', 'bottom', 'left'].some(function (t) { return e[t] >= 0 }) } var N = ['top', 'bottom', 'right', 'left']; const V = N.reduce(function (e, t) { return e.concat([t + '-start', t + '-end']) }, []); const I = [].concat(N, ['auto']).reduce(function (e, t) { return e.concat([t, t + '-start', t + '-end']) }, []); var _ = 'beforeRead read afterRead beforeMain main afterMain beforeWrite write afterWrite'.split(' '); var U = Math.max; var z = Math.min; var F = Math.round; var X = { placement: 'bottom', modifiers: [], strategy: 'absolute' }; const Y = { passive: !0 }; const G = { name: 'eventListeners', enabled: !0, phase: 'write', fn: function () {}, effect: function (e) { const t = e.state; const o = e.instance; const r = (e = e.options).scroll; const i = void 0 === r || r; const a = void 0 === (e = e.resize) || e; const s = n(t.elements.popper); const f = [].concat(t.scrollParents.reference, t.scrollParents.popper); return i && f.forEach(function (e) { e.addEventListener('scroll', o.update, Y) }), a && s.addEventListener('resize', o.update, Y), function () { i && f.forEach(function (e) { e.removeEventListener('scroll', o.update, Y) }), a && s.removeEventListener('resize', o.update, Y) } }, data: {} }; const J = { name: 'popperOffsets', enabled: !0, phase: 'read', fn: function (e) { const t = e.state; t.modifiersData[e.name] = M({ reference: t.rects.reference, element: t.rects.popper, strategy: 'absolute', placement: t.placement }) }, data: {} }; var K = { top: 'auto', right: 'auto', bottom: 'auto', left: 'auto' }; const Q = { name: 'computeStyles', enabled: !0, phase: 'beforeWrite', fn: function (e) { const t = e.state; let n = e.options; e = void 0 === (e = n.gpuAcceleration) || e; let o = n.adaptive; o = void 0 === o || o, n = void 0 === (n = n.roundOffsets) || n, e = { placement: x(t.placement), variation: L(t.placement), popper: t.elements.popper, popperRect: t.rects.popper, gpuAcceleration: e }, t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, R(Object.assign({}, e, { offsets: t.modifiersData.popperOffsets, position: t.options.strategy, adaptive: o, roundOffsets: n })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, R(Object.assign({}, e, { offsets: t.modifiersData.arrow, position: 'absolute', adaptive: !1, roundOffsets: n })))), t.attributes.popper = Object.assign({}, t.attributes.popper, { 'data-popper-placement': t.placement }) }, data: {} }; const Z = { name: 'applyStyles', enabled: !0, phase: 'write', fn: function (e) { const t = e.state; Object.keys(t.elements).forEach(function (e) { const n = t.styles[e] || {}; const o = t.attributes[e] || {}; const r = t.elements[e]; i(r) && s(r) && (Object.assign(r.style, n), Object.keys(o).forEach(function (e) { const t = o[e]; !1 === t ? r.removeAttribute(e) : r.setAttribute(e, !0 === t ? '' : t) })) }) }, effect: function (e) { const t = e.state; const n = { popper: { position: t.options.strategy, left: '0', top: '0', margin: '0' }, arrow: { position: 'absolute' }, reference: {} }; return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function () { Object.keys(t.elements).forEach(function (e) { const o = t.elements[e]; const r = t.attributes[e] || {}; e = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : n[e]).reduce(function (e, t) { return e[t] = '', e }, {}), i(o) && s(o) && (Object.assign(o.style, e), Object.keys(r).forEach(function (e) { o.removeAttribute(e) })) }) } }, requires: ['computeStyles'] }; const $ = { name: 'offset', enabled: !0, phase: 'main', requires: ['popperOffsets'], fn: function (e) { const t = e.state; const n = e.name; const o = void 0 === (e = e.options.offset) ? [0, 0] : e; let r = (e = I.reduce(function (e, n) { let r = t.rects; let i = x(n); const a = ['left', "top"].indexOf(i) >= 0 ? -1 : 1; let s = typeof o === 'function' ? o(Object.assign({}, r, { placement: n })) : o; return r = (r = s[0]) || 0, s = ((s = s[1]) || 0) * a, i = ['left', 'right'].indexOf(i) >= 0 ? { x: s, y: r } : { x: r, y: s }, e[n] = i, e }, {}))[t.placement]; const i = r.x; r = r.y, t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += i, t.modifiersData.popperOffsets.y += r), t.modifiersData[n] = e } }; var ee = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' }; var te = { start: 'end', end: 'start' }; const ne = { name: 'flip', enabled: !0, phase: 'main', fn: function (e) { const t = e.state; let n = e.options; if (e = e.name, !t.modifiersData[e]._skip) { let o = n.mainAxis; o = void 0 === o || o; let r = n.altAxis; r = void 0 === r || r; let i = n.fallbackPlacements; const a = n.padding; const s = n.boundary; const f = n.rootBoundary; const p = n.altBoundary; let c = n.flipVariations; const l = void 0 === c || c; const u = n.allowedAutoPlacements; c = x(n = t.options.placement), i = i || (c !== n && l ? (function (e) { if (x(e) === 'auto') return []; const t = H(e); return [S(e), t, S(t)] }(n)) : [H(n)]); const d = [n].concat(i).reduce(function (e, n) { return e.concat(x(n) === 'auto' ? (function (e, t) { void 0 === t && (t = {}); const n = t.boundary; const o = t.rootBoundary; const r = t.padding; let i = t.flipVariations; const a = t.allowedAutoPlacements; const s = void 0 === a ? I : a; const f = L(t.placement); (i = (t = f ? i ? V : V.filter(function (e) { return L(e) === f }) : N).filter(function (e) { return s.indexOf(e)>=0})).length === 0 && (i = t); const p = i.reduce(function (t, i) { return t[i] = B(e, { placement: i, boundary: n, rootBoundary: o, padding: r })[x(i)], t }, {}); return Object.keys(p).sort(function (e, t) { return p[e] - p[t] }) }(t, { placement: n, boundary: s, rootBoundary: f, padding: a, flipVariations: l, allowedAutoPlacements: u })) : n) }, []); n = t.rects.reference, i = t.rects.popper; const m = new Map(); c = !0; for (var h = d[0], v = 0; v < d.length; v++) { const g = d[v]; const b = x(g); let y = L(g) === 'start'; let w = ['top', 'bottom'].indexOf(b) >= 0; let O = w ? 'width' : 'height'; const j = B(t, { placement: g, boundary: s, rootBoundary: f, altBoundary: p, padding: a }); if (y = w ? y ? 'right' : 'left' : y ? 'bottom' : 'top', n[O] > i[O] && (y = H(y)), O = H(y), w = [], o && w.push(j[b] <= 0), r && w.push(j[y] <= 0, j[O] <= 0), w.every(function (e) { return e })) { h = g, c = !1; break }m.set(g, w) } if (c) for (o = function (e) { const t = d.find(function (t) { if (t = m.get(t)) return t.slice(0, e).every(function (e) { return e }) }); if (t) return h = t, 'break' }, r = l ? 3 : 1; r > 0 && o(r) !== 'break'; r--);t.placement !== h && (t.modifiersData[e]._skip = !0, t.placement = h, t.reset = !0) } }, requiresIfExists: ['offset'], data: { _skip: !1 } }; const oe = { name: 'preventOverflow', enabled: !0, phase: 'main', fn: function (e) { const t = e.state; let n = e.options; e = e.name; let o = n.mainAxis; let r = void 0 === o || o; let i = void 0 !== (o = n.altAxis) && o; o = void 0 === (o = n.tether) || o; let a = n.tetherOffset; let s = void 0 === a ? 0 : a; let f = B(t, { boundary: n.boundary, rootBoundary: n.rootBoundary, padding: n.padding, altBoundary: n.altBoundary }); n = x(t.placement); let p = L(t.placement); let c = !p; const l = P(n); n = l === 'x' ? 'y' : 'x', a = t.modifiersData.popperOffsets; let u = t.rects.reference; let m = t.rects.popper; let h = typeof s === 'function' ? s(Object.assign({}, t.rects, { placement: t.placement })) : s; if (s = { x: 0, y: 0 }, a) { if (r || i) { let v = l === 'y' ? 'top' : 'left'; let g = l === 'y' ? 'bottom' : 'right'; const y = l === 'y' ? 'height' : 'width'; const w = a[l]; const O = a[l] + f[v]; let j = a[l] - f[g]; const E = o ? -m[y] / 2 : 0; let D = p === 'start' ? u[y] : m[y]; p = p === 'start' ? -m[y] : -u[y], m = t.elements.arrow, m = o && m ? d(m) : { width: 0, height: 0 }; const M = t.modifiersData['arrow#persistent'] ? t.modifiersData['arrow#persistent'].padding : { top: 0, right: 0, bottom: 0, left: 0 }; v = M[v], g = M[g], m = U(0, z(u[y], m[y])), D = c ? u[y] / 2 - E - m - v - h : D - m - v - h, u = c ? -u[y] / 2 + E + m + g + h : p + m + g + h, c = t.elements.arrow && b(t.elements.arrow), h = t.modifiersData.offset ? t.modifiersData.offset[t.placement][l] : 0, c = a[l] + D - h - (c ? l === 'y' ? c.clientTop || 0 : c.clientLeft || 0 : 0), u = a[l] + u - h, r && (r = o ? z(O, c) : O, j = o ? U(j, u) : j, r = U(r, z(w, j)), a[l] = r, s[l] = r - w), i && (r = (i = a[n]) + f[l === 'x' ? 'top' : 'left'], f = i - f[l === 'x' ? 'bottom' : 'right'], r = o ? z(r, c) : r, o = o ? U(f, u) : f, o = U(r, z(i, o)), a[n] = o, s[n] = o - i) }t.modifiersData[e] = s } }, requiresIfExists: ['offset'] }; const re = { name: 'arrow', enabled: !0, phase: 'main', fn: function (e) { let t; const n = e.state; const o = e.name; let r = e.options; let i = n.elements.arrow; let a = n.modifiersData.popperOffsets; let s = x(n.placement); if (e = P(s), s = ['left', 'right'].indexOf(s) >= 0 ? 'height' : 'width', i && a) { r = k(typeof (r = typeof (r = r.padding) === 'function' ? r(Object.assign({}, n.rects, { placement: n.placement })) : r) !== 'number' ? r : A(r, N)); const f = d(i); const p = e === 'y' ? 'top' : 'left'; const c = e === 'y' ? 'bottom' : 'right'; const l = n.rects.reference[s] + n.rects.reference[e] - a[e] - n.rects.popper[s]; a = a[e] - n.rects.reference[e], a = (i = (i = b(i)) ? e === 'y' ? i.clientHeight || 0 : i.clientWidth || 0 : 0) / 2 - f[s] / 2 + (l / 2 - a / 2), s = U(r[p], z(a, i - f[s] - r[c])), n.modifiersData[o] = ((t = {})[e] = s, t.centerOffset = s - a, t) } }, effect: function (e) { const t = e.state; if ((e = void 0 === (e = e.options.element) ? '[data-popper-arrow]' : e) != null) { if (typeof e === 'string' && !(e = t.elements.popper.querySelector(e))) return; O(t.elements.popper, e) && (t.elements.arrow = e) } }, requires: ['popperOffsets'], requiresIfExists: ['preventOverflow'] }; const ie = { name: 'hide', enabled: !0, phase: 'main', requiresIfExists: ['preventOverflow'], fn: function (e) { const t = e.state; e = e.name; let n = t.rects.reference; let o = t.rects.popper; let r = t.modifiersData.preventOverflow; const i = B(t, { elementContext: 'reference' }); let a = B(t, { altBoundary: !0 }); n = C(i, n), o = C(a, o, r), r = q(n), a = q(o), t.modifiersData[e] = { referenceClippingOffsets: n, popperEscapeOffsets: o, isReferenceHidden: r, hasPopperEscaped: a }, t.attributes.popper = Object.assign({}, t.attributes.popper, { 'data-popper-reference-hidden': r, 'data-popper-escaped': a }) } }; const ae = T({ defaultModifiers: [G, J, Q, Z] }); const se = [G, J, Q, Z, $, ne, oe, re, ie]; const fe = T({ defaultModifiers: se }); e.applyStyles = Z, e.arrow = re, e.computeStyles = Q, e.createPopper = fe, e.createPopperLite = ae, e.defaultModifiers = se, e.detectOverflow = B, e.eventListeners = G, e.flip = ne, e.hide = ie, e.offset = $, e.popperGenerator = T, e.popperOffsets = J, e.preventOverflow = oe, Object.defineProperty(e, '__esModule', { value: !0 }) }))
